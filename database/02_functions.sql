-- Function to populate the dim_time table for a full 24-hour cycle
CREATE OR REPLACE FUNCTION populate_dim_time()
RETURNS VOID AS $$
BEGIN

    INSERT INTO dim_time (hour, minute, seconds)
    SELECT
        h AS hour,
        m AS minute,
        s AS seconds
    FROM
        -- Generate hours from 0 to 23
        generate_series(0, 23) AS h
    CROSS JOIN
        -- Generate minutes from 0 to 59
        generate_series(0, 59) AS m
    CROSS JOIN
        -- Generate seconds from 0 to 59
        generate_series(0, 59) AS s

    ON CONFLICT (time_key) DO NOTHING;
END;
$$ LANGUAGE plpgsql;


-- Create data for date dimension
CREATE OR REPLACE FUNCTION populate_dim_date(
    start_date DATE DEFAULT '2025-01-01',
    end_date DATE DEFAULT '2030-12-31'
)
RETURNS VOID AS $$
BEGIN
    INSERT INTO dim_date (
        year,
        month,
        day,
        week_number,
        day_of_week,
        day_name_of_week,
        day_of_year
    )
    SELECT
        -- 'd' is the alias for the date generated by generate_series
        EXTRACT(YEAR FROM d) AS year,
        EXTRACT(MONTH FROM d) AS month,
        EXTRACT(DAY FROM d) AS day,
        EXTRACT(WEEK FROM d) AS week_number,
        EXTRACT(ISODOW FROM d) AS day_of_week,
        TRIM(TO_CHAR(d, 'Day')) AS day_name_of_week,
        EXTRACT(DOY FROM d) AS day_of_year
    FROM
        -- Generate one row for every date between the start and end dates
        generate_series(start_date, end_date, '1 day'::interval) AS d;

END;
$$ LANGUAGE plpgsql;


-- create locations
CREATE OR REPLACE FUNCTION populate_dim_locations()
RETURNS VOID AS $$
BEGIN
    INSERT INTO dim_locations (country_name, latitude, longitude) 
    VALUES
        ('India', '20.593684', '78.96288'),
        ('USA', '37.09024',	'-95.712891'),
        ('UK', '55.378051', '-3.435973'),
        ('Japan', '36.204824', '138.252924'),
        ('Germany', '51.165691', '10.451526'),
        ('Australia', '-25.274398', '133.775136');
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION populate_dim_users(
    start_num INTEGER DEFAULT 1,
    end_num INTEGER DEFAULT 20
)
RETURNS VOID AS $$
BEGIN
    IF start_num <= 0 OR end_num <= 0 OR start_num > end_num THEN
        RAISE EXCEPTION 'Invalid range: start_num (%) must be positive and less than or equal to end_num (%).', start_num, end_num;
    END IF;

    -- Use generate_series to create numbers from start_num to end_num
    INSERT INTO dim_users (user_name)
    SELECT
        -- Format the integer as a 4-digit zero-padded string, then prepend 'user_'
        'user_' || LPAD(i::text, 4, '0') AS user_name
    FROM
        generate_series(start_num, end_num) AS i;

END;
$$ LANGUAGE plpgsql;